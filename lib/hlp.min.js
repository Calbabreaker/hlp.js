/* 
  The hlp.js library by Calbabreaker. 
  Free to use. GPL-3.0 
*/

const hlp={FULL:0,math:{}};hlp.math.TWO_PI=2*hlp.math.PI,hlp.math.FOUR_PI=4*hlp.math.PI,hlp.math.HALF_PI=hlp.math.PI/2,hlp.math.QUARTER_PI=hlp.math.PI/4,Object.getOwnPropertyNames(window.Math).forEach(t=>{hlp.math[t]=window.Math[t]}),hlp.math.map=((t,e,s,i,r)=>i+(r-i)*(t-e)/(s-e)),hlp.math.toRadians=(t=>t*hlp.math.PI/180),hlp.math.toDegrees=(t=>t*(180/hlp.math.PI)),hlp.math.lerp=((t,e,s)=>s*(e-t)+t),hlp.math.constrain=((t,e,s)=>hlp.math.max(hlp.math.min(t,s),e)),hlp.random=((t,e)=>Math.random()*(t-e)+e),hlp.Matrix=class{constructor(t=0,e=0){t instanceof Array?(this.data=t,this.rows=this.data.length,this.cols=this.data[0].length):(this.rows=t,this.cols=e,this.data=new Array(t).fill().map(()=>new Array(e).fill(0)))}static add(t,e){return new hlp.Matrix(t.rows,t.cols).add(e)}add(t){if(t instanceof hlp.Matrix){if(this.cols!==t.cols||this.rows!==t.rows)throw new Error("Both matrixs rows and cols must match!");return this.map((e,s,i)=>e+t.data[s][i])}if("number"==typeof t)return this.map(e=>e+t);throw new Error("Did not provide valid data for parameter toAdd!")}static sub(t,e){return new hlp.Matrix(t.rows,t.cols).sub(e)}sub(t){if(t instanceof hlp.Matrix){if(this.cols!==t.cols||this.rows!==t.rows)throw new Error("Both matrixs rows and cols must match!");return this.map((e,s,i)=>e-t.data[s][i])}if("number"==typeof t)return this.map(e=>e-t);throw new Error("Did not provide valid data for parameter toSub!")}static dotMult(t,e){if(t.cols!==e.rows)throw new Error("hlp.Matrix a cols must match matrix b rows!");return new hlp.Matrix(t.rows,e.cols).map((s,i,r)=>{let o=0;for(let s=0;s<t.cols;s++)o+=t.data[i][s]*e.data[s][r];return o})}static multVector(t,e){if(!(t instanceof hlp.Vector))throw new Error("vec must be a vector");if(4!=e.cols||4!=e.rows)throw new Error("matrix must have 4 cols and 4 rows!");const s=new hlp.Vector(t.x,t.y,t.z);s.x=t.x*e.get(0,0)+t.y*e.get(1,0)+t.z*e.get(2,0)+e.get(3,0),s.y=t.x*e.get(0,1)+t.y*e.get(1,1)+t.z*e.get(2,1)+e.get(3,1),s.z=t.x*e.get(0,2)+t.y*e.get(1,2)+t.z*e.get(2,2)+e.get(3,2);const i=t.x*e.get(0,3)+t.y*e.get(1,3)+t.z*e.get(2,3)+e.get(3,3);return 0!=i&&s.div(i),s}static quickInverse(t){const e=new hlp.Matrix([[t.get(0,0),t.get(1,0),t.get(2,0),0],[t.get(0,1),t.get(1,1),t.get(2,1),0],[t.get(0,2),t.get(1,2),t.get(2,2),0],[0,0,0,0]]);return e.set(3,0,-(t.get(3,0)*e.get(0,0)+t.get(3,1)*e.get(1,0)+t.get(3,2)*e.get(2,0))),e.set(3,1,-(t.get(3,0)*e.get(0,1)+t.get(3,1)*e.get(1,1)+t.get(3,2)*e.get(2,1))),e.set(3,2,-(t.get(3,0)*e.get(0,2)+t.get(3,1)*e.get(1,2)+t.get(3,2)*e.get(2,2))),e.set(3,3,1),e}static mult(t,e){return new hlp.Matrix(t.rows,t.cols).mult(e)}mult(t){if(t instanceof hlp.Matrix){if(this.cols!==t.cols||this.rows!==t.rows)throw new Error("Both matrixs rows and cols must match!");return this.map((e,s,i)=>e*t.data[s][i])}if("number"==typeof t)return this.map(e=>e*t);throw new Error("Did not provide valid data for parameter toMult!")}static div(t,e){return new hlp.Matrix(t.rows,t.cols).div(e)}div(t){if(t instanceof hlp.Matrix){if(this.cols!==t.cols||this.rows!==t.rows)throw new Error("Both matrixs rows and cols must match!");return this.map((e,s,i)=>e/t.data[s][i])}if("number"==typeof t)return this.map(e=>e/t);throw new Error("Did not provide valid data for parameter toDiv!")}randomize(t=0,e=1){return this.map(()=>hlp.random(t,e))}randomizeGuassian(t=0,e=1){if("undefined"==typeof p5)throw new Error("Cant use randomGaussian (no p5)");return this.map(()=>randomGaussian(t,e))}max(){let t=0;return hlp.Matrix.map(this,e=>{e>t&&(t=e)}),t}sum(){let t=0;return hlp.Matrix.map(this,e=>t+=e),t}exp(){return this.map(Math.exp)}floor(){return this.map(Math.floor)}fill(t){return this.map(()=>t)}set(t,e,s){return this.data[t][e]=s,this}get(t,e){return this.data[t][e]}constrain(t,e){return this.map(s=>Math.min(Math.max(s,t),e))}softmax(){return this.sub(this.max()).exp(),this.div(this.sum())}map(t){for(let e=0;e<this.rows;e++)for(let s=0;s<this.cols;s++){const i=this.data[e][s];this.data[e][s]=t(i,e,s)}return this}static map(t,e){return new hlp.Matrix(t.rows,t.cols).map((s,i,r)=>e(t.data[i][r],i,r))}static transpose(t){return new hlp.Matrix(t.cols,t.rows).map((e,s,i)=>t.data[i][s])}log(){return console.table(this.data),this}copy(){return hlp.Matrix.map(this,t=>t)}toArray(){return this.copy().data}static createFromVector(t){return new hlp.Matrix([[t.x],[t.y],[t.z],[0]])}toVector(){if(this.rows>=3)return new hlp.Vector(this.data[0][0],this.data[1][0],this.data[2][0]);throw new Error("hlp.Matrix cannot be converted to a vector")}static createIdentity(){return new hlp.Matrix([[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]])}static createRotationX(t){return new hlp.Matrix([[1,0,0,0],[0,Math.cos(t),Math.sin(t),0],[0,-Math.sin(t),Math.cos(t),0],[0,0,0,1]])}static createRotationY(t){return new hlp.Matrix([[Math.cos(t),0,Math.sin(t),0],[0,1,0,0],[-Math.sin(t),0,Math.cos(t),0],[0,0,0,1]])}static createRotationZ(t){return new hlp.Matrix([[Math.cos(t),Math.sin(t),0,0],[-Math.sin(t),Math.cos(t),0,0],[0,0,1,0],[0,0,0,1]])}static createTranslation(t,e,s){return new hlp.Matrix([[1,0,0,0],[0,1,0,0],[0,0,1,0],[t,e,s,1]])}static createProjectionOrtho(){return new hlp.Matrix([[1,0,0,0],[0,1,0,0],[0,0,0,0],[0,0,0,0]])}static createProjectionPerspect(t,e,s,i){const r=hlp.math.toRadians(t);return new hlp.Matrix([[e*r,0,0,0],[0,r,0,0],[0,0,i/(i-s),1],[0,0,-i*s/(i-s),0]])}static createPointAt(t,e,s){const i=hlp.Vector.sub(e,t).normalise(),r=hlp.Vector.sub(s,hlp.Vector.mult(i,s.dotProduct(i))).normalise(),o=hlp.Vector.crossProduct(r,i);return new hlp.Matrix([[o.x,o.y,o.z],[r.x,r.y,r.z],[i.x,i.y,i.z],[t.x,t.y,t.z]])}},hlp.Vector=class{constructor(t=0,e=0,s=0){this.x=t,this.y=e,this.z=s}add(t){return t instanceof hlp.Vector?(this.x+=t.x,this.y+=t.y,this.z+=t.z):(this.x+=t,this.y+=t,this.z+=t),this}static add(t,e){return t.copy().add(e)}sub(t){return t instanceof hlp.Vector?(this.x-=t.x,this.y-=t.y,this.z-=t.z):(this.x-=t,this.y-=t,this.z-=t),this}static sub(t,e){return t.copy().sub(e)}div(t){return t instanceof hlp.Vector?(this.x/=t.x,this.y/=t.y,this.z/=t.z):(this.x/=t,this.y/=t,this.z/=t),this}static div(t,e){return t.copy().div(e)}mult(t){return t instanceof hlp.Vector?(this.x*=t.x,this.y*=t.y,this.z*=t.z):(this.x*=t,this.y*=t,this.z*=t),this}static mult(t,e){return t.copy().mult(e)}static crossProduct(t,e){const s=new hlp.Vector;return s.x=t.y*e.z-t.z*e.y,s.y=t.z*e.x-t.x*e.z,s.z=t.x*e.y-t.y*e.x,s}dotProduct(t){return this.x*t.x+this.y*t.y+this.z*t.z}copy(){return new hlp.Vector(this.x,this.y,this.z)}set(t=0,e=0,s=0){this.x=t,this.y=e,this.z=s}magSq(){return this.x*this.x+this.y*this.y+this.z*this.z}mag(){return hlp.math.sqrt(this.magSq())}normalise(){const t=this.mag();return 0!==t&&this.mult(1/t),this}static normalise(t){return t.copy().normalise()}setMag(t){return this.normalise().mult(t)}heading(){const t=hlp.math.atan2(this.y,this.x);return hlp.math.toDegrees(t)}rotate(t){const e=hlp.math.toRadians(this.heading()+t),s=this.mag();return this.x=hlp.math.cos(e)*s,this.y=hlp.math.sin(e)*s,this}static fromAngle(t,e=1){return t=hlp.math.toRadians(t),new hlp.Vector(e*hlp.math.cos(t),e*hlp.math.sin(t),0)}static intersectPlane(t,e,s,i){const r=-(e=hlp.Vector.normalise(e)).dotProduct(t),o=s.dotProduct(e),h=(-r-o)/(i.dotProduct(e)-o);return hlp.Vector.sub(i,s).mult(h).add(s)}},document.exitPointerLock=document.exitPointerLock||document.mozExitPointerLock,hlp.Canvas=class{constructor(t=400,e=400,s){if(t===hlp.FULL?(null!=s&&(this.aspectRatio=new hlp.Vector(s/e,1)),this.isFull=!0,this._calcResize()):(this.width=t,this.height=e),this._doFill=!0,this._doStroke=!0,this._prevDoFills=[],this._prevDoStrokes=[],this._firstPosShapes=null,this.frameCount=0,this.targetFPS=60,this.hasStopped=!1,this.fpsInterval=1e3/this.targetFPS,this.fps=this.targetFPS,this.canvas=document.createElement("canvas"),this.canvas.setAttribute("id","defaultCanvas"),this.canvas.width=this.width,this.canvas.height=this.height,this.clientRect=this.canvas.getBoundingClientRect(),!this.canvas.getContext)return alert("Browser does not support the canvas.");this.ctx=this.canvas.getContext("2d"),document.body.appendChild(this.canvas),this.keyPressingDict={},this.keyCodePressingDict={},this.canvas.requestPointerLock=this.canvas.requestPointerLock||this.canvas.mozRequestPointerLock,this._then=Date.now(),this._deltaTimeMS=0,this.deltaTime=0,this.mouse=new hlp.Vector(0,0),this.mouseMovement=new hlp.Vector(0,0),this.mouseIsLocked=!1,this.isFull&&(window.onresize=(t=>{this._calcResize()})),document.body.addEventListener("mousemove",t=>{this.mouse.set(t.clientX-this.clientRect.left,t.clientY-this.clientRect.top),this.mouseMovement.set(t.movementX,t.movementY),this.mouseMove(),this.mouseIsLocked?this.lockedMouseMove():this.unlockedMouseMove()}),document.addEventListener("pointerlockchange",()=>this.mouseIsLocked=!this.mouseIsLocked,!1),document.addEventListener("mozpointerlockchange",()=>this.mouseIsLocked=!this.mouseIsLocked,!1),document.body.addEventListener("mousedown",t=>{this.mousePressed()}),document.body.addEventListener("keydown",t=>{this.keyPressingDict[t.key]=!0,this.keyCodePressingDict[t.code]=!0}),document.body.addEventListener("keyup",t=>{this.keyPressingDict[t.key]=!1,this.keyCodePressingDict[t.code]=!1}),this.animationDrawFunc=(()=>{try{this._now=Date.now(),this._deltaTimeMS=this._now-this._then,this.deltaTime=this._deltaTimeMS/1e3,this._deltaTimeMS>this.fpsInterval&&!this.hasStopped&&(this.fps=1e3/this._deltaTimeMS,this.updateCycle(),this._then=this._now-this._deltaTimeMS%this.fpsInterval)}catch(t){return console.error(t)}requestAnimationFrame(this.animationDrawFunc)}),setTimeout(()=>{this.preload().then(()=>{this.setup(),this.animationDrawFunc()})})}setup(){}draw(){}async preload(){}mousePressed(){}mouseMove(){}lockedMouseMove(){}unlockedMouseMove(){}updateCycle(){this.push(),this.draw(),this.pop()}stop(){this.hasStopped=!0}start(){this.hasStopped=!1,this._then=Date.now()}keyIsDown(t){return this.keyPressingDict[t]}keyCodeIsDown(t){return this.keyCodePressingDict[t]}lockMouse(){this.canvas.requestPointerLock()}unlockMouse(){document.exitPointerLock()}changeFPS(t){this.targetFPS=t,this.fps=t,this.fpsInterval=1e3/t,this._then=Date.now()}fill(...t){if(this._doFill=!0,"string"==typeof t[0])this.ctx.fillStyle,t[0];else{if("number"!=typeof t[0])throw new Error("Invalid param for fill!");if(1==t.length)this.ctx.fillStyle=`rgb(${t[0]}, ${t[0]}, ${t[0]})`;else if(3==t.length)this.ctx.fillStyle=`rgb(${t[0]}, ${t[1]}, ${t[2]})`;else{if(!(t.length>=4))throw new Error("Invalid param for fill!");this.ctx.fillStyle=`rgb(${t[0]}, ${t[1]}, ${t[2]}, ${t[3]})`}}}stroke(...t){if(this._doStroke=!0,"string"==typeof t[0])this.ctx.strokeStyle,t[0];else{if("number"!=typeof t[0])throw new Error("Invalid param for stroke!");if(1==t.length)this.ctx.strokeStyle=`rgb(${t[0]}, ${t[0]}, ${t[0]})`;else if(3==t.length)this.ctx.strokeStyle=`rgb(${t[0]}, ${t[1]}, ${t[2]})`;else{if(!(t.length>=4))throw new Error("Invalid param for stroke!");this.ctx.strokeStyle=`rgb(${t[0]}, ${t[1]}, ${t[2]}, ${t[3]})`}}}noFill(){this._doFill=!1}noStroke(){this._doStroke=!1}strokeWeight(t){this.ctx.lineWidth=t}beginShape(){if(null!=this._firstPosShapes)throw new Error("Cannot beginShape before closing/ending!");this.ctx.beginPath()}endShape(t=!0){if(null==this._firstPosShapes)throw new Error("Cannot endShape before begining one!");t&&this.ctx.closePath(this._firstPosShapes.x,this._firstPosShapes.y),this._doFill&&this.ctx.fill(),this._doStroke&&this.ctx.stroke(),this._firstPosShapes=null}vertex(t,e){null==this._firstPosShapes?(this._firstPosShapes=new hlp.Vector(t,e),this.ctx.moveTo(t,e)):this.ctx.lineTo(t,e)}rect(t,e,s,i){this._doFill&&this.ctx.fillRect(t,e,s,i),this._doStroke&&this.ctx.strokeRect(t,e,s,i)}triangle(...t){if(this.beginShape(),t[0]instanceof hlp.Vector)this.vertex(t[0].x,t[0].y),this.vertex(t[1].x,t[1].y),this.vertex(t[2].x,t[2].y);else{if("number"!=typeof t[0])throw new Error("Invalid data for shape");this.vertex(t[0],t[1]),this.vertex(t[2],t[3]),this.vertex(t[4],t[5])}this.endShape()}triangleInflate(t,e,s){const i=new hlp.Vector(t.x+e.x+s.x,t.y+e.y+s.y).div(3);t=hlp.Vector.sub(t,i),e=hlp.Vector.sub(e,i),s=hlp.Vector.sub(s,i),this.triangle(t.setMag(t.mag()+1).add(i),e.setMag(e.mag()+1).add(i),s.setMag(s.mag()+1).add(i))}point(t,e){this.rect(t,e,1,1)}line(...t){if(this.beginShape(),t[0]instanceof hlp.Vector)this.vertex(t[0].x,t[0].y),this.vertex(t[1].x,t[1].y);else{if("number"!=typeof t[0])throw new Error("Invalid data for line.");this.vertex(t[0],t[1]),this.vertex(t[2],t[3])}this.endShape(!1)}background(...t){this.push(),this.fill(...t),this.noStroke(),this.rect(0,0,this.width,this.height),this.pop()}translate(t,e=0){this.ctx.translate(t,e)}rotate(t){this.ctx.rotate(t*hlp.math.toRadians())}scale(t,e=0){this.ctx.scale(t,e)}push(){this._prevDoFills.push(this._doFill),this._prevDoStrokes.push(this._doStroke),this.ctx.save()}pop(){this._doFill=this._prevDoFills.pop(),this._doStroke=this._prevDoStrokes.pop(),this.ctx.restore()}_calcResize(){let t=innerHeight;if(null!=this.aspectRatio){const e=innerWidth/this.aspectRatio.x;e<innerHeight&&(t=e)}this.width=null!=this.aspectRatio?t*this.aspectRatio.x:innerWidth,this.height=t,null!=this.canvas&&(this.canvas.width=this.width,this.canvas.height=this.height)}},hlp.Triangle=class{constructor(){this.points=new Array(3),this.illumination=0}static clipAgainstPlane(t,e,s){hlp.Vector.normalise(e);const i=[],r=[],o=s=>e.x*s.x+e.y*s.y+e.z*s.z-e.dotProduct(t),h=o(s.points[0]),n=o(s.points[1]),a=o(s.points[2]);if(h>=0?i.push(s.points[0]):r.push(s.points[0]),n>=0?i.push(s.points[1]):r.push(s.points[1]),a>=0?i.push(s.points[2]):r.push(s.points[2]),0==i.length)return[];if(3==i.length)return[s];if(1==i.length&&2==r.length){const o=new hlp.Triangle;return o.illumination=s.illumination,o.points[0]=i[0].copy(),o.points[1]=hlp.Vector.intersectPlane(t,e,i[0],r[0]),o.points[2]=hlp.Vector.intersectPlane(t,e,i[0],r[1]),[o]}if(2==i.length&&1==r.length){const o=new hlp.Triangle,h=new hlp.Triangle;return o.illumination=s.illumination,h.illumination=s.illumination,o.points[0]=i[0].copy(),o.points[1]=i[1].copy(),o.points[2]=hlp.Vector.intersectPlane(t,e,i[0],r[0]),h.points[0]=i[1].copy(),h.points[1]=o.points[2].copy(),h.points[2]=hlp.Vector.intersectPlane(t,e,i[1],r[0]),[o,h]}}},hlp.Mesh=class{constructor(t=[]){this.tris=t}static async loadFromFile(t){if("obj"!=t.split(".").pop())throw new Error("Can only support obj models");const e=await fetch(t),s=await e.text(),i=new hlp.Mesh,r=[];return s.split("\n").forEach(t=>{if("v"==(t=t.split(/ +/g))[0])r.push(new hlp.Vector(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3])));else if("f"==t[0]){const e=[t[1].split(/\/+/g)[0],t[2].split(/\/+/g)[0],t[3].split(/\/+/g)[0]],s=new hlp.Triangle;s.points[0]=r[parseInt(e[0])-1],s.points[1]=r[parseInt(e[1])-1],s.points[2]=r[parseInt(e[2])-1],i.tris.push(s)}}),i}},hlp.RendererCPU=class{constructor(t){this.c=t,this.rotation=0,this.cameraPos=new hlp.Vector,this.lookDir=new hlp.Vector,this.yawY=0,this.yawX=0,this.lightDirection=new hlp.Vector(0,0,1).normalise(),this.near=.1,this.far=1e3,this.fov=90,this.aspectRatio=this.c.height/this.c.width,this.projectionMatrix=hlp.Matrix.createProjectionPerspect(this.fov,this.aspectRatio,this.near,this.far)}draw(t){this.c.push(),this.c.noStroke(),this.c.translate(this.c.width/2,this.c.height/2),this.c.scale(1,-1),this.rotation+=.1;let e=hlp.Matrix.createTranslation(0,0,5);const s=new hlp.Vector(0,1,0);let i=new hlp.Vector(0,0,1);const r=hlp.Matrix.dotMult(hlp.Matrix.createRotationX(this.yawY),hlp.Matrix.createRotationY(this.yawX));this.lookDir=hlp.Matrix.multVector(i,r),i=hlp.Vector.add(this.cameraPos,this.lookDir);const o=hlp.Matrix.createPointAt(this.cameraPos,i,s),h=hlp.Matrix.quickInverse(o);let n=[];t.tris.forEach((t,s)=>{const i=new hlp.Triangle;i.points[0]=hlp.Matrix.multVector(t.points[0],e),i.points[1]=hlp.Matrix.multVector(t.points[1],e),i.points[2]=hlp.Matrix.multVector(t.points[2],e);const r=hlp.Vector.sub(i.points[1],i.points[0]),o=hlp.Vector.sub(i.points[2],i.points[0]),a=hlp.Vector.crossProduct(r,o).normalise(),l=hlp.Vector.sub(i.points[0],this.cameraPos);if(a.dotProduct(l)<0){const t=a.dotProduct(this.lightDirection);i.points[0]=hlp.Matrix.multVector(i.points[0],h),i.points[1]=hlp.Matrix.multVector(i.points[1],h),i.points[2]=hlp.Matrix.multVector(i.points[2],h),hlp.Triangle.clipAgainstPlane(new hlp.Vector(0,0,.1),new hlp.Vector(0,0,1),i).forEach(e=>{const s=new hlp.Triangle;s.points[0]=hlp.Matrix.multVector(e.points[0],this.projectionMatrix),s.points[1]=hlp.Matrix.multVector(e.points[1],this.projectionMatrix),s.points[2]=hlp.Matrix.multVector(e.points[2],this.projectionMatrix),s.illumination=t;const i=new hlp.Vector(1,1,0);s.points[0].add(i),s.points[1].add(i),s.points[2].add(i);const r=new hlp.Vector(.5*this.c.width,.5*this.c.height,1);s.points[0].mult(r),s.points[1].mult(r),s.points[2].mult(r),n.push(s)})}}),n.sort((t,e)=>{const s=(t.points[0].z+t.points[1].z+t.points[2].z)/3;return(e.points[0].z+e.points[1].z+e.points[2].z)/3-s});const a=new hlp.Vector(this.c.width/2,this.c.height/2);n.forEach(t=>{const e=[];e.push(t);for(let t=0;t<4;t++)for(;e<0;){const s=e[0];switch(e.shift(),t){case 0:e.push(...hlp.Triangle.clipAgainstPlane(new hlp.Vector(0,0,0),new hlp.Vector(0,1,0),s));break;case 1:e.push(...hlp.Triangle.clipAgainstPlane(new hlp.Vector(0,this.c.height-1,0),new Vector(0,-1,0),s));break;case 2:e.push(...hlp.Triangle.clipAgainstPlane(new hlp.Vector(0,0,0),new hlp.Vector(1,0,0),s));break;case 3:e.push(...hlp.Triangle.clipAgainstPlane(new hlp.Vector(this.c.width-1,0,0),new hlp.Vector(-1,0,0),s))}}e.forEach(t=>{this.c.fill(-255*t.illumination),this.c.triangleInflate(t.points[0].sub(a),t.points[1].sub(a),t.points[2].sub(a))})}),this.c.pop()}};class AudioPlayer{constructor(){const t=window.AudioContext||window.webkitAudioContext;this.context=new t,this.reset()}play(t,e,s,i=0){return this.hasResseted?(null!=t&&this.setFreq(t),null!=s&&this.setWaveType(s),null!=e&&this.setVolume(e),this.oscillator.start(i),this.hasResseted=!1,this):console.error("Make sure you reset the AudioPlayer before playing!")}stop(t=0,e=!1){return e&&(this.gain.gain.setValueAtTime(this.gain.gain.value,this.context.currentTime),this.gain.gain.exponentialRampToValueAtTime(1e-5,this.context.currentTime+t)),this.oscillator.stop(this.context.currentTime+t),this}reset(t=this.context.destination){return this.gain=this.context.createGain(),this.gain.connect(t),this.oscillator=this.context.createOscillator(),this.oscillator.connect(this.gain),this.compressor=this.context.createDynamicsCompressor(),this.compressor.connect(this.context.destination),this.hasResseted=!0,this}setWaveType(t){return this.oscillator.type=t,this}setFreq(t){this.oscillator.frequency.value=t}setVolume(t){return this.gain.gain.value=t,this}}hlp.Dictionary=class{constructor(){this.data={}}contains(t){return null!=this.data[t.toString()]}get(t){return this.data[t.toString()]}set(t,e){return this.data[t.toString()]=e,this}add(t,e){return this.data[t.toString()]=e,this}remove(t){return this.data[t.toString()]=null,this}};